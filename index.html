<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>尖叫爆发器Plus版 - 终极增强版</title>
    <style>
        /* 基础样式重置和全页面设置 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            touch-action: none; /* 防止浏览器处理触摸事件 */
            transition: background 0.8s ease;
        }
        
        /* 游戏容器 */
        #gameContainer {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            position: relative;
            z-index: 5;
        }
        
        /* 动态背景效果 */
        #dynamicBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 0;
            background-size: 400% 400%;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }
        
        /* 波浪背景 */
        .wave-container {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            top: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 2;
            opacity: 0;
            transition: opacity 0.8s ease;
        }
        
        .wave {
            position: absolute;
            left: -100%;
            width: 300%;
            height: 100%;
            background-repeat: repeat-x;
            transform-origin: center bottom;
            opacity: 0.1;
        }
        
        .wave1 {
            background-image: radial-gradient(circle at center, transparent 30%, rgba(255, 255, 255, 0.2) 30%);
            background-size: 60px 60px;
            animation: wave-animation 18s linear infinite;
            bottom: 0;
            height: 120%;
        }
        
        .wave2 {
            background-image: radial-gradient(circle at center, transparent 30%, rgba(255, 255, 255, 0.3) 30%);
            background-size: 90px 90px;
            animation: wave-animation 15s linear infinite reverse;
            bottom: 0;
            height: 120%;
        }
        
        .wave3 {
            background-image: radial-gradient(circle at center, transparent 30%, rgba(255, 255, 255, 0.15) 30%);
            background-size: 120px 120px;
            animation: wave-animation 20s linear infinite;
            bottom: 0;
            height: 120%;
        }
        
        @keyframes wave-animation {
            0% {
                transform: translateX(0) translateY(0) scaleY(1);
            }
            50% {
                transform: translateX(25%) translateY(5px) scaleY(1.1);
            }
            100% {
                transform: translateX(50%) translateY(0) scaleY(1);
            }
        }
        
        /* 头部 */
        #gameHeader {
            width: 100%;
            text-align: center;
            padding: 10px;
            font-size: 24px;
            font-weight: bold;
            z-index: 10;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: color 0.5s ease;
        }
        
        /* 主游戏区域 */
        #gameplayArea {
            flex: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* 嘴巴按钮 */
        #mouthButton {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff8585 0%, #ff6b6b 70%, #ff5252 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 60px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.3s, clip-path 0.5s, border-radius 0.5s;
            user-select: none;
            z-index: 20;
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.4), 
                        0 2px 8px rgba(0, 0, 0, 0.2),
                        inset 0 -2px 5px rgba(0, 0, 0, 0.1),
                        inset 0 2px 5px rgba(255, 255, 255, 0.5);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        #mouthButton::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.5) 0%, rgba(255, 255, 255, 0) 60%);
            pointer-events: none;
            transition: transform 0.3s;
        }
        
        #mouthButton:active {
            transform: scale(0.95);
            box-shadow: 0 4px 10px rgba(255, 107, 107, 0.3), 
                        0 1px 4px rgba(0, 0, 0, 0.15),
                        inset 0 -1px 3px rgba(0, 0, 0, 0.2),
                        inset 0 1px 3px rgba(255, 255, 255, 0.3);
        }
        
        /* 按钮内部波纹 */
        #buttonRipple {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.7) 0%, rgba(255, 255, 255, 0) 70%);
            transform: scale(0);
            opacity: 0;
            pointer-events: none;
            z-index: 2;
        }
        
        @keyframes buttonRipple {
            0% {
                transform: scale(0);
                opacity: 0.7;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
        
        /* 特效容器 */
        #effectsContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 5;
        }
        
        /* 压力计 */
        #pressureMeter {
            width: 80%;
            height: 24px;
            background-color: rgba(221, 221, 221, 0.5);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 20px;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2), 
                        0 1px 2px rgba(255, 255, 255, 0.5);
            border: 1px solid rgba(200, 200, 200, 0.8);
        }
        
        #pressureBar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, 
                            #4facfe 0%, 
                            #00f2fe 50%, 
                            #ff9a8b 75%, 
                            #ff6a88 87%, 
                            #ff0844 100%);
            background-size: 200% 100%;
            transition: width 0.1s;
            box-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
            position: relative;
            overflow: hidden;
        }
        
        #pressureBar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(to bottom, 
                            rgba(255, 255, 255, 0.3) 0%, 
                            rgba(255, 255, 255, 0) 100%);
        }
        
        #pressureValue {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            font-weight: bold;
            color: #333;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
            z-index: 1;
        }
        
        /* 打卡面板 */
        #checkinPanel {
            width: 90%;
            max-height: 40%;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            margin-top: 20px;
            overflow-y: auto;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1), 
                        0 4px 12px rgba(0, 0, 0, 0.1);
            display: none;
            z-index: 30;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        
        .checkinHeader {
            text-align: center;
            margin-bottom: 15px;
            font-weight: bold;
            padding: 8px;
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.1) 0%, rgba(0, 242, 254, 0.1) 100%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            color: #333;
        }
        
        .checkinGrid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
        }
        
        .checkinDay {
            padding: 5px;
            text-align: center;
            border-radius: 8px;
            background-color: #f0f0f0;
            font-size: 14px;
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .checkinDay:not(.active):hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .checkinDay.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            box-shadow: 0 4px 8px rgba(79, 172, 254, 0.3);
        }
        
        .checkinValue {
            font-size: 10px;
            position: absolute;
            bottom: 2px;
            right: 2px;
            padding: 1px 3px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            color: #ff6b6b;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        /* 统计数据容器 */
        #statsContainer {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 5px;
            border-radius: 10px;
            background-color: rgba(240, 240, 240, 0.5);
        }
        
        .statItem {
            flex: 1;
            text-align: center;
            padding: 8px 5px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.7);
            margin: 0 3px;
        }
        
        .statLabel {
            font-size: 12px;
            color: #666;
            margin-bottom: 3px;
        }
        
        .statValue {
            font-weight: bold;
            color: #ff6a88;
            font-size: 14px;
        }
        
        /* 控制按钮 */
        #controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 12px;
            z-index: 40;
        }
        
        .controlButton {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15),
                        inset 0 -2px 5px rgba(0, 0, 0, 0.05),
                        inset 0 2px 5px rgba(255, 255, 255, 0.8);
            cursor: pointer;
            font-size: 22px;
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.8);
        }
        
        .controlButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15),
                        inset 0 -2px 5px rgba(0, 0, 0, 0.05),
                        inset 0 2px 5px rgba(255, 255, 255, 0.8);
        }
        
        .controlButton:active {
            transform: translateY(1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1),
                        inset 0 -1px 3px rgba(0, 0, 0, 0.05),
                        inset 0 1px 3px rgba(255, 255, 255, 0.8);
        }
        
        /* 超级模式指示器 */
        .superModeIndicator {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #ff9a8b 0%, #ff0844 100%);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(255, 8, 68, 0.5);
            z-index: 30;
            animation: pulseIndicator 1.5s infinite;
        }
        
        @keyframes pulseIndicator {
            0% {
                transform: translateX(-50%) scale(1);
            }
            50% {
                transform: translateX(-50%) scale(1.05);
            }
            100% {
                transform: translateX(-50%) scale(1);
            }
        }
        
        /* 声波动画 */
        @keyframes soundWave {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }
        
        .soundWave {
            position: absolute;
            border-radius: 50%;
            border: 2px solid #ff6b6b;
            animation: soundWave 1s infinite;
            pointer-events: none;
        }
        
        /* 弹出消息 */
        #popupMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 18px;
            z-index: 50;
            display: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            animation: popupFade 0.3s ease-out;
        }
        
        @keyframes popupFade {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        /* 成就系统样式 */
        #achievementPopup {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, 0);
            background: linear-gradient(135deg, #ff9a8b 0%, #ff6a88 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 16px;
            z-index: 51;
            display: none;
            box-shadow: 0 15px 35px rgba(255, 106, 136, 0.4);
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.3);
            animation: achievementSlide 0.5s ease-out;
        }
        
        @keyframes achievementSlide {
            from {
                opacity: 0;
                transform: translate(-50%, -20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }
        
        #achievementPopup .achievementTitle {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        #achievementPopup .achievementDesc {
            font-size: 14px;
            opacity: 0.9;
        }
        
        /* 高级特效样式 */
        .neonParticle {
            position: absolute;
            border-radius: 50%;
            filter: blur(2px);
            box-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
        }
        
        .textEffect {
            position: absolute;
            font-weight: bold;
            text-shadow: 0 0 10px currentColor;
            animation: textFade 1.5s forwards;
        }
        
        @keyframes textFade {
            0% {
                opacity: 0;
                transform: scale(0.8) rotate(0deg);
            }
            20% {
                opacity: 1;
                transform: scale(1.1) rotate(3deg);
            }
            80% {
                opacity: 1;
                transform: scale(1.1) rotate(-3deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.9) translateY(10px) rotate(0deg);
            }
        }
        
        .shockwave {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 70%);
            opacity: 0.8;
            animation: shockwaveExpand 0.8s forwards;
            pointer-events: none;
        }
        
        @keyframes shockwaveExpand {
            0% {
                transform: scale(0);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 0;
            }
        }
        
        /* 形变动画 */
        @keyframes morphAnimation {
            0% {
                transform: rotate(0deg) scale(1);
            }
            25% {
                transform: rotate(5deg) scale(1.05);
            }
            50% {
                transform: rotate(0deg) scale(1.1);
            }
            75% {
                transform: rotate(-5deg) scale(1.05);
            }
            100% {
                transform: rotate(0deg) scale(1);
            }
        }
        
        /* 背景颜色渐变动画 */
        @keyframes bgColorShift {
            0% {
                background-color: rgba(255, 0, 0, 0.05);
            }
            20% {
                background-color: rgba(255, 165, 0, 0.05);
            }
            40% {
                background-color: rgba(255, 255, 0, 0.05);
            }
            60% {
                background-color: rgba(0, 128, 0, 0.05);
            }
            80% {
                background-color: rgba(0, 0, 255, 0.05);
            }
            100% {
                background-color: rgba(128, 0, 128, 0.05);
            }
        }
        
        /* 新特效样式 */
        .emojiExplosion {
            position: absolute;
            font-size: 30px;
            animation: emojiFloat 3s forwards;
            z-index: 6;
        }
        
        @keyframes emojiFloat {
            0% {
                transform: translateY(0) rotate(0deg) scale(0.5);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(-10px) rotate(5deg) scale(1);
            }
            90% {
                opacity: 1;
                transform: translateY(-100px) rotate(-5deg) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translateY(-120px) rotate(0deg) scale(0.8);
            }
        }
        
        /* 星星特效 */
        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            animation: twinkle 2s infinite ease-in-out;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            z-index: 4;
            pointer-events: none;
        }
        
        @keyframes twinkle {
            0%, 100% {
                opacity: 0.2;
                transform: scale(0.8);
            }
            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }
        
        /* 闪电特效 */
        .lightning {
            position: absolute;
            background: linear-gradient(to bottom, white, transparent);
            width: 2px;
            transform-origin: top;
            animation: lightning 0.5s ease-out forwards;
            z-index: 4;
        }
        
        @keyframes lightning {
            0% {
                opacity: 1;
                height: 0;
            }
            100% {
                opacity: 0;
                height: 100vh;
            }
        }
        
        /* 霓虹发光边框 */
        .glowingBorder {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            animation: glowingBorder 3s infinite;
            z-index: 1;
            pointer-events: none;
        }
        
        @keyframes glowingBorder {
            0%, 100% {
                box-shadow: 0 0 5px rgba(255, 0, 0, 0.7), 0 0 20px rgba(255, 0, 0, 0.5), inset 0 0 10px rgba(255, 0, 0, 0.3);
            }
            25% {
                box-shadow: 0 0 5px rgba(255, 165, 0, 0.7), 0 0 20px rgba(255, 165, 0, 0.5), inset 0 0 10px rgba(255, 165, 0, 0.3);
            }
            50% {
                box-shadow: 0 0 5px rgba(0, 255, 0, 0.7), 0 0 20px rgba(0, 255, 0, 0.5), inset 0 0 10px rgba(0, 255, 0, 0.3);
            }
            75% {
                box-shadow: 0 0 5px rgba(0, 0, 255, 0.7), 0 0 20px rgba(0, 0, 255, 0.5), inset 0 0 10px rgba(0, 0, 255, 0.3);
            }
        }
        
        /* 响应式适配不同设备尺寸 */
        @media (max-height: 600px) {
            #mouthButton {
                width: 100px;
                height: 100px;
                font-size: 50px;
            }
            
            #checkinPanel {
                max-height: 30%;
            }
            
            .statItem {
                padding: 5px 3px;
            }
            
            .statLabel {
                font-size: 10px;
            }
        }
        
        @media (max-width: 360px) {
            #mouthButton {
                width: 90px;
                height: 90px;
                font-size: 45px;
            }
            
            .checkinGrid {
                grid-template-columns: repeat(7, 1fr);
                gap: 2px;
            }
            
            .checkinDay {
                font-size: 12px;
            }
            
            #controls {
                gap: 8px;
            }
            
            .controlButton {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div id="dynamicBackground"></div>
    <div class="wave-container" id="waveContainer">
        <div class="wave wave1"></div>
        <div class="wave wave2"></div>
        <div class="wave wave3"></div>
    </div>
    
    <div id="gameContainer">
        <div id="gameHeader">尖叫爆发器Plus版</div>
        
        <div id="gameplayArea">
            <div id="mouthButton">
                😮
                <div id="buttonRipple"></div>
                <div class="glowingBorder"></div>
            </div>
            <div id="effectsContainer"></div>
        </div>
        
        <div id="pressureMeter">
            <div id="pressureBar"></div>
            <div id="pressureValue">0</div>
        </div>
        
        <div id="checkinPanel">
            <div class="checkinHeader">
                本月最高释放值: <span id="monthMax">0</span>
            </div>
            <div id="statsContainer">
                <div class="statItem">
                    <div class="statLabel">累计释放</div>
                    <div class="statValue" id="totalPressureReleased">0</div>
                </div>
                <div class="statItem">
                    <div class="statLabel">历史最高</div>
                    <div class="statValue" id="allTimeMax">0</div>
                </div>
                <div class="statItem">
                    <div class="statLabel">本周释放</div>
                    <div class="statValue" id="weeklyTotal">0</div>
                </div>
            </div>
            <div class="checkinGrid" id="checkinGrid"></div>
        </div>
        
        <div id="controls">
            <div class="controlButton" id="toggleCheckin">📅</div>
            <div class="controlButton" id="toggleEffects">✨</div>
            <div class="controlButton" id="toggleSuper">🔥</div>
            <div class="controlButton" id="toggleSound">🔊</div>
        </div>
    </div>
    
    <div id="popupMessage"></div>
    <div id="achievementPopup">
        <div class="achievementTitle">新成就解锁！</div>
        <div class="achievementDesc"></div>
    </div>
    
    <script>
        // 游戏状态
        const gameState = {
            isPressed: false,
            pressStartTime: 0,
            currentPressure: 0,
            maxPressure: 0,
            lastPressureUpdate: 0,
            pressureIncreaseRate: 2, // 每100ms增加的基础百分比
            pressureTier: 0, // 压力等级，影响视觉效果
            effectsEnabled: true,
            soundEnabled: true,
            checkinVisible: false,
            particles: [],
            soundWaves: [],
            neonParticles: [],
            textEffects: [],
            shockwaves: [],
            stars: [],
            lightnings: [],
            maxParticles: 500, // 增加性能限制
            touchType: '', // 'short', 'long', 或 'rapid'
            rapidPressCount: 0,
            rapidPressTimeout: null,
            animationFrameId: null,
            lastFrame: 0,
            superModeActive: false,
            superModeTimer: null,
            achievements: [], // 成就系统
            totalPressureReleased: 0, // 累计释放压力
            sessionStartTime: Date.now(), // 本次会话开始时间
            customEffectsUnlocked: [], // 解锁的自定义效果
            backgroundAnimationActive: false,
            buttonMorphLevel: 0, // 按钮变形等级
            buttonMorphPoints: 8, // 变形多边形的点数
            buttonMorphAngles: [], // 变形多边形的角度
            buttonMorphRadii: [], // 变形多边形的半径
            morphAnimationActive: false, // 变形动画状态
            lastBackgroundUpdateTime: 0, // 最后一次背景更新时间
            waveAnimationActive: false, // 波浪动画状态
            starCreationInterval: null, // 星星创建间隔
            dynamicEffectsEnabled: true // 动态特效开关
        };
        
        // 成就定义
        const achievements = [
            { id: 'first-scream', title: '初次尖叫', description: '完成你的第一次尖叫', unlockAt: 1, type: 'pressure', unlocked: false },
            { id: 'pressure-100', title: '解压高手', description: '达到100点压力值', unlockAt: 100, type: 'pressure', unlocked: false },
            { id: 'pressure-500', title: '尖叫之王', description: '达到500点压力值', unlockAt: 500, type: 'pressure', unlocked: false },
            { id: 'pressure-1000', title: '压力释放大师', description: '达到1000点压力值', unlockAt: 1000, type: 'pressure', unlocked: false },
            { id: 'pressure-2000', title: '超越极限', description: '突破2000点压力值', unlockAt: 2000, type: 'pressure', unlocked: false },
            { id: 'total-pressure-5000', title: '持续减压', description: '累计释放5000点压力', unlockAt: 5000, type: 'totalPressure', unlocked: false },
            { id: 'total-pressure-10000', title: '减压专家', description: '累计释放10000点压力', unlockAt: 10000, type: 'totalPressure', unlocked: false },
            { id: 'rapid-master', title: '快速按压专家', description: '完成10次快速按压', unlockAt: 10, type: 'rapidPress', unlocked: false },
            { id: 'daily-3', title: '坚持不懈', description: '连续3天打卡', unlockAt: 3, type: 'consecutive', unlocked: false },
            { id: 'daily-7', title: '一周坚持', description: '连续7天打卡', unlockAt: 7, type: 'consecutive', unlocked: false },
            { id: 'super-mode', title: '超级模式', description: '解锁超级释放模式', unlockAt: 300, type: 'pressure', unlocked: false },
            { id: 'morph-master', title: '形变大师', description: '体验形变效果', unlockAt: 800, type: 'pressure', unlocked: false }
        ];
        
        // 自定义效果定义
        const customEffects = [
            { id: 'neon-explosion', name: '霓虹爆炸', unlockAt: 200, type: 'pressure', enabled: false },
            { id: 'text-shower', name: '文字雨', unlockAt: 300, type: 'pressure', enabled: false },
            { id: 'color-shift', name: '颜色变换', unlockAt: 500, type: 'pressure', enabled: false },
            { id: 'shockwave', name: '冲击波', unlockAt: 400, type: 'pressure', enabled: false },
            { id: 'star-field', name: '星空效果', unlockAt: 700, type: 'pressure', enabled: false },
            { id: 'lightning', name: '闪电效果', unlockAt: 900, type: 'pressure', enabled: false },
            { id: 'wave-background', name: '波浪背景', unlockAt: 600, type: 'pressure', enabled: false },
            { id: 'button-morph', name: '按钮形变', unlockAt: 800, type: 'pressure', enabled: false }
        ];
        
        // DOM元素
        const mouthButton = document.getElementById('mouthButton');
        const buttonRipple = document.getElementById('buttonRipple');
        const effectsContainer = document.getElementById('effectsContainer');
        const pressureBar = document.getElementById('pressureBar');
        const pressureValue = document.getElementById('pressureValue');
        const checkinPanel = document.getElementById('checkinPanel');
        const checkinGrid = document.getElementById('checkinGrid');
        const monthMax = document.getElementById('monthMax');
        const popupMessage = document.getElementById('popupMessage');
        const toggleCheckin = document.getElementById('toggleCheckin');
        const toggleEffects = document.getElementById('toggleEffects');
        const toggleSuper = document.getElementById('toggleSuper');
        const toggleSound = document.getElementById('toggleSound');
        const dynamicBackground = document.getElementById('dynamicBackground');
        const waveContainer = document.getElementById('waveContainer');
        const gameHeader = document.getElementById('gameHeader');
        
        // 初始化按钮形变参数
        function initButtonMorphParams() {
            const points = gameState.buttonMorphPoints;
            gameState.buttonMorphAngles = [];
            gameState.buttonMorphRadii = [];
            
            for (let i = 0; i < points; i++) {
                // 均匀分布的角度，添加一些随机性
                gameState.buttonMorphAngles.push((i / points) * 2 * Math.PI);
                // 初始半径一致（圆形）
                gameState.buttonMorphRadii.push(50); // 50%的半径，相对于按钮大小
            }
        }
        
        // 更新按钮的形状
        function updateButtonShape(pressure) {
            if (!gameState.customEffectsUnlocked.includes('button-morph') || !gameState.dynamicEffectsEnabled) {
                // 如果未解锁形变效果，保持圆形
                mouthButton.style.borderRadius = '50%';
                mouthButton.style.clipPath = 'none';
                return;
            }
            
            // 形变强度基于压力值
            const morphIntensity = Math.min(pressure / 2000, 0.6); // 最大变形幅度60%
            const points = gameState.buttonMorphPoints;
            
            // 随机更新角度和半径
            for (let i = 0; i < points; i++) {
                // 角度小幅度波动
                if (Math.random() < 0.1) {
                    gameState.buttonMorphAngles[i] += (Math.random() - 0.5) * 0.05;
                }
                
                // 半径波动
                if (Math.random() < 0.2) {
                    // 基础半径 + 随机波动 * 形变强度
                    const fluctuation = (Math.random() - 0.5) * 30 * morphIntensity;
                    gameState.buttonMorphRadii[i] = 50 + fluctuation;
                    // 确保不会太小或太大
                    gameState.buttonMorphRadii[i] = Math.max(30, Math.min(70, gameState.buttonMorphRadii[i]));
                }
            }
            
            // 构建clip-path多边形
            let clipPath = 'polygon(';
            const centerX = 50; // 中心点的X坐标 (%)
            const centerY = 50; // 中心点的Y坐标 (%)
            
            for (let i = 0; i < points; i++) {
                const angle = gameState.buttonMorphAngles[i];
                const radius = gameState.buttonMorphRadii[i];
                
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                clipPath += `${x}% ${y}%`;
                
                if (i < points - 1) {
                    clipPath += ', ';
                }
            }
            
            clipPath += ')';
            mouthButton.style.clipPath = clipPath;
            mouthButton.style.borderRadius = '0'; // 使用clip-path时需要禁用borderRadius
        }
        
        // 初始化形变
        initButtonMorphParams();
        
        // 触发按钮形变动画
        function triggerButtonMorphAnimation() {
            if (!gameState.morphAnimationActive && gameState.customEffectsUnlocked.includes('button-morph') && gameState.dynamicEffectsEnabled) {
                gameState.morphAnimationActive = true;
                mouthButton.style.animation = 'morphAnimation 0.5s ease-in-out';
                
                setTimeout(() => {
                    mouthButton.style.animation = 'none';
                    gameState.morphAnimationActive = false;
                }, 500);
            }
        }
        
        // 更新背景颜色
        function updateBackgroundColor(pressure) {
            if (!gameState.dynamicEffectsEnabled) return;
            
            // 每500ms才更新一次背景，避免频繁更新
            const now = Date.now();
            if (now - gameState.lastBackgroundUpdateTime < 500) return;
            gameState.lastBackgroundUpdateTime = now;
            
            // 基于压力值计算HSL颜色
            // 从蓝色(220)过渡到红色(0)
            const hue = Math.max(220 - (pressure / 15), 0);
            // 饱和度随压力增加
            const saturation = Math.min(70 + (pressure / 20), 100);
            // 亮度稍微降低，创造强烈感
            const lightness = Math.max(90 - (pressure / 40), 60);
            
            // 设置背景色
            document.body.style.background = `linear-gradient(135deg, hsl(${hue}, ${saturation}%, ${lightness}%) 0%, hsl(${hue + 20}, ${saturation - 10}%, ${lightness - 10}%) 100%)`;
            
            // 更新标题颜色，确保可读性
            if (pressure > 800) {
                gameHeader.style.color = 'white';
                gameHeader.style.textShadow = '0 2px 4px rgba(0, 0, 0, 0.3)';
            } else {
                gameHeader.style.color = '#333';
                gameHeader.style.textShadow = '0 2px 4px rgba(255, 255, 255, 0.3)';
            }
            
            // 高压力下激活动态背景
            if (pressure > 600 && gameState.customEffectsUnlocked.includes('color-shift')) {
                const intensity = Math.min((pressure - 600) / 1400, 0.8);
                dynamicBackground.style.opacity = intensity.toFixed(2);
                dynamicBackground.style.background = `linear-gradient(45deg, 
                    rgba(255,0,0,${intensity * 0.3}), 
                    rgba(255,255,0,${intensity * 0.3}), 
                    rgba(0,255,0,${intensity * 0.3}), 
                    rgba(0,255,255,${intensity * 0.3}), 
                    rgba(0,0,255,${intensity * 0.3}), 
                    rgba(255,0,255,${intensity * 0.3}))`;
                dynamicBackground.style.backgroundSize = '400% 400%';
                dynamicBackground.style.animation = 'bgColorShift 8s ease infinite';
            } else {
                dynamicBackground.style.opacity = '0';
                dynamicBackground.style.animation = 'none';
            }
            
            // 激活波浪背景
            if (pressure > 500 && gameState.customEffectsUnlocked.includes('wave-background') && !gameState.waveAnimationActive) {
                gameState.waveAnimationActive = true;
                waveContainer.style.opacity = '1';
            } else if (pressure < 400 && gameState.waveAnimationActive) {
                gameState.waveAnimationActive = false;
                waveContainer.style.opacity = '0';
            }
        }
        
        // 触发按钮波纹效果
        function triggerButtonRipple() {
            buttonRipple.style.animation = 'none';
            void buttonRipple.offsetWidth; // 触发重绘
            buttonRipple.style.animation = 'buttonRipple 0.8s ease-out';
        }
        
        // 创建星星效果
        function createStarField() {
            if (!gameState.customEffectsUnlocked.includes('star-field') || !gameState.dynamicEffectsEnabled) return;
            
            if (gameState.currentPressure > 700 && gameState.starCreationInterval === null) {
                // 每200ms创建一个星星
                gameState.starCreationInterval = setInterval(() => {
                    if (gameState.stars.length > 50) return; // 限制最大数量
                    
                    const star = document.createElement('div');
                    star.className = 'star';
                    
                    // 随机位置
                    const x = Math.random() * window.innerWidth;
                    const y = Math.random() * window.innerHeight;
                    
                    // 随机大小
                    const size = 1 + Math.random() * 3;
                    
                    star.style.left = `${x}px`;
                    star.style.top = `${y}px`;
                    star.style.width = `${size}px`;
                    star.style.height = `${size}px`;
                    
                    // 随机动画延迟
                    star.style.animationDelay = `${Math.random() * 2}s`;
                    
                    // 添加到DOM
                    effectsContainer.appendChild(star);
                    
                    // 添加到数组
                    gameState.stars.push({
                        element: star,
                        duration: 5000 + Math.random() * 5000,
                        elapsed: 0
                    });
                    
                }, 200);
            } else if (gameState.currentPressure < 600 && gameState.starCreationInterval !== null) {
                clearInterval(gameState.starCreationInterval);
                gameState.starCreationInterval = null;
            }
        }
        
        // 创建闪电效果
        function createLightning(pressure) {
            if (!gameState.customEffectsUnlocked.includes('lightning') || !gameState.dynamicEffectsEnabled) return;
            
            if (gameState.lightnings.length > 3) return; // 限制同时存在的闪电数量
            
            const lightning = document.createElement('div');
            lightning.className = 'lightning';
            
            // 随机位置
            const x = Math.random() * window.innerWidth;
            lightning.style.left = `${x}px`;
            lightning.style.top = '0';
            
            // 随机旋转
            const rotate = (Math.random() - 0.5) * 30;
            lightning.style.transform = `rotate(${rotate}deg)`;
            
            // 随机宽度
            const width = 1 + Math.random() * 3;
            lightning.style.width = `${width}px`;
            
            // 根据压力调整亮度
            const opacity = Math.min(0.5 + (pressure / 2000), 1);
            lightning.style.opacity = opacity;
            
            // 添加到DOM
            effectsContainer.appendChild(lightning);
            
            // 添加到数组
            gameState.lightnings.push({
                element: lightning,
                duration: 500,
                elapsed: 0
            });
        }
        
        // 检查存储是否可用
        function storageAvailable(type) {
            try {
                const storage = window[type];
                const x = '__storage_test__';
                storage.setItem(x, x);
                storage.removeItem(x);
                return true;
            } catch (e) {
                return false;
            }
        }
        
        // 本地存储功能
        function saveCheckin(pressure) {
            if (!storageAvailable('localStorage')) return;
            
            const today = new Date();
            const dateKey = today.toISOString().split('T')[0]; // YYYY-MM-DD
            const monthKey = dateKey.substring(0, 7); // YYYY-MM
            const weekStart = getWeekStart(today).toISOString().split('T')[0]; // 本周开始日期
            
            // 获取现有数据
            let checkinData = JSON.parse(localStorage.getItem('screamCheckinData') || '{}');
            let statsData = JSON.parse(localStorage.getItem('screamStatsData') || '{}');
            
            // 更新今天的数据
            if (!checkinData[dateKey] || pressure > checkinData[dateKey]) {
                checkinData[dateKey] = pressure;
            }
            
            // 更新历史最高值
            if (!statsData.allTimeMax || pressure > statsData.allTimeMax) {
                statsData.allTimeMax = pressure;
            }
            
            // 更新月最大值
            let monthMaxValue = 0;
            for (const date in checkinData) {
                if (date.startsWith(monthKey) && checkinData[date] > monthMaxValue) {
                    monthMaxValue = checkinData[date];
                }
            }
            
            // 更新本周累计释放值
            if (!statsData.weeklyData) {
                statsData.weeklyData = {};
            }
            
            if (!statsData.weeklyData[weekStart]) {
                statsData.weeklyData[weekStart] = pressure;
            } else {
                // 如果今天已经记录过，则只加上差值
                const oldValue = checkinData[dateKey] || 0;
                const diff = Math.max(pressure - oldValue, 0);
                statsData.weeklyData[weekStart] += diff;
            }
            
            // 更新累计释放总值
            if (!statsData.totalReleased) {
                statsData.totalReleased = pressure;
            } else {
                // 如果今天已经记录过，则只加上差值
                const oldValue = checkinData[dateKey] || 0;
                const diff = Math.max(pressure - oldValue, 0);
                statsData.totalReleased += diff;
            }
            
            // 检查连续打卡
            if (!statsData.consecutiveDays) {
                statsData.consecutiveDays = 1;
                statsData.lastCheckin = dateKey;
            } else {
                const lastDate = new Date(statsData.lastCheckin);
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                if (lastDate.toISOString().split('T')[0] === yesterday.toISOString().split('T')[0]) {
                    // 昨天打过卡，连续天数+1
                    statsData.consecutiveDays++;
                    statsData.lastCheckin = dateKey;
                    
                    // 检查连续打卡成就
                    if (statsData.consecutiveDays === 3) {
                        const achievement = achievements.find(a => a.id === 'daily-3');
                        if (achievement && !achievement.unlocked) {
                            achievement.unlocked = true;
                            showAchievement(achievement.title, achievement.description);
                            saveAchievements();
                        }
                    }
                    
                    if (statsData.consecutiveDays === 7) {
                        const achievement = achievements.find(a => a.id === 'daily-7');
                        if (achievement && !achievement.unlocked) {
                            achievement.unlocked = true;
                            showAchievement(achievement.title, achievement.description);
                            saveAchievements();
                        }
                    }
                } else if (lastDate.toISOString().split('T')[0] !== dateKey) {
                    // 不是昨天也不是今天，重置连续天数
                    statsData.consecutiveDays = 1;
                    statsData.lastCheckin = dateKey;
                }
            }
            
            // 保存数据
            localStorage.setItem('screamCheckinData', JSON.stringify(checkinData));
            localStorage.setItem('screamStatsData', JSON.stringify(statsData));
            
            // 更新游戏状态
            gameState.totalPressureReleased = statsData.totalReleased || 0;
            
            // 更新UI
            updateCheckinDisplay();
        }
        
        function loadCheckinData() {
            if (!storageAvailable('localStorage')) return {};
            
            return JSON.parse(localStorage.getItem('screamCheckinData') || '{}');
        }
        
        // 获取本周开始日期（周一）
        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // 调整为周一
            return new Date(d.setDate(diff));
        }
        
        // 加载统计数据
        function loadStatsData() {
            if (!storageAvailable('localStorage')) return {};
            
            return JSON.parse(localStorage.getItem('screamStatsData') || '{}');
        }
        
        function updateCheckinDisplay() {
            // 清除现有网格
            checkinGrid.innerHTML = '';
            
            const today = new Date();
            const currentMonth = today.getMonth();
            const currentYear = today.getFullYear();
            
            // 月份第一天
            const firstDay = new Date(currentYear, currentMonth, 1);
            // 月份最后一天
            const lastDay = new Date(currentYear, currentMonth + 1, 0);
            
            // 第一天的星期（0=周日，6=周六）
            const firstDayOfWeek = firstDay.getDay();
            const daysInMonth = lastDay.getDate();
            
            // 创建星期标题（周日-周六）
            const weekDays = ['日', '一', '二', '三', '四', '五', '六'];
            weekDays.forEach(day => {
                const dayHeader = document.createElement('div');
                dayHeader.className = 'checkinDay';
                dayHeader.style.backgroundColor = '#ddd';
                dayHeader.textContent = day;
                checkinGrid.appendChild(dayHeader);
            });
            
            // 为月份第一天之前添加空单元格
            for (let i = 0; i < firstDayOfWeek; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.className = 'checkinDay';
                emptyDay.style.visibility = 'hidden';
                checkinGrid.appendChild(emptyDay);
            }
            
            // 获取打卡数据
            const checkinData = loadCheckinData();
            
            // 获取统计数据
            const statsData = loadStatsData();
            
            // 计算月最大值
            let monthMaxValue = 0;
            const monthKey = today.toISOString().substring(0, 7); // YYYY-MM
            
            for (const date in checkinData) {
                if (date.startsWith(monthKey) && checkinData[date] > monthMaxValue) {
                    monthMaxValue = checkinData[date];
                }
            }
            
            // 更新月最大值显示
            monthMax.textContent = monthMaxValue.toFixed(0);
            
            // 更新其他统计数据显示
            document.getElementById('totalPressureReleased').textContent = 
                (statsData.totalReleased || 0).toFixed(0);
            
            document.getElementById('allTimeMax').textContent = 
                (statsData.allTimeMax || 0).toFixed(0);
            
            // 计算本周释放总值
            const weekStart = getWeekStart(today).toISOString().split('T')[0];
            document.getElementById('weeklyTotal').textContent = 
                ((statsData.weeklyData && statsData.weeklyData[weekStart]) || 0).toFixed(0);
            
            // 添加月份的天数
            for (let i = 1; i <= daysInMonth; i++) {
                const dayCell = document.createElement('div');
                dayCell.className = 'checkinDay';
                dayCell.textContent = i;
                
                // 检查这一天是否有打卡
                const dateString = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${i.toString().padStart(2, '0')}`;
                
                if (checkinData[dateString]) {
                    dayCell.classList.add('active');
                    
                    // 添加压力值
                    const valueSpan = document.createElement('div');
                    valueSpan.className = 'checkinValue';
                    valueSpan.textContent = checkinData[dateString].toFixed(0);
                    dayCell.appendChild(valueSpan);
                    
                    // 如果是历史最高值，添加特殊标记
                    if (checkinData[dateString] === statsData.allTimeMax) {
                        dayCell.style.boxShadow = '0 0 8px rgba(255, 8, 68, 0.7)';
                        dayCell.style.background = 'linear-gradient(135deg, #ff6a88 0%, #ff0844 100%)';
                    }
                }
                
                // 如果是今天，添加特殊标记
                if (i === today.getDate()) {
                    dayCell.style.border = '2px solid #ff9a8b';
                }
                
                checkinGrid.appendChild(dayCell);
            }
        }
        
        // 特效生成功能
        function createParticle(pressure) {
            if (!gameState.effectsEnabled || gameState.particles.length >= gameState.maxParticles) return;
            
            // 创建粒子元素
            const particle = document.createElement('div');
            particle.style.position = 'absolute';
            particle.style.pointerEvents = 'none';
            
            // 在按钮周围随机定位
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const angle = Math.random() * Math.PI * 2;
            
            // 根据压力调整距离和效果
            let distance, content, fontSize, color, duration, directionX, directionY;
            
            // 超级模式增强效果
            const superMultiplier = gameState.superModeActive ? 1.5 : 1;
            
            // 随着压力值增大，动态增加粒子复杂度
            if (pressure < 50) {
                // 低压力：简单文本
                distance = 50 + (Math.random() * pressure * 1.8);
                
                const options = ['a', 'あ', '啊', '아', '!', '?', '😮', '😯', '😲', '😣', 'oh', 'Ah'];
                content = options[Math.floor(Math.random() * options.length)];
                fontSize = (12 + Math.random() * 10) * superMultiplier;
                
                const hue = Math.floor(180 + Math.random() * 60); // 蓝色-青色范围
                color = `hsl(${hue}, 80%, 60%)`;
                
                duration = 1000 + Math.random() * 1000;
                directionX = (Math.random() - 0.5) * (pressure / 15);
                directionY = (Math.random() - 0.5 - 0.3) * (pressure / 12);
            } else if (pressure < 150) {
                // 中等压力：更具表现力
                distance = 60 + (Math.random() * pressure * 2);
                
                const options = [
                    'AA', 'ああ', '啊啊', '아아', '!!', '?!', '😮', '😲', '😱', '😫',
                    'OH', 'AHH', 'WOW', 'GAH', 'EEK', 'AGHH'
                ];
                content = options[Math.floor(Math.random() * options.length)];
                fontSize = (16 + Math.random() * 14) * superMultiplier;
                
                const hue = Math.floor(280 + Math.random() * 60); // 紫色-洋红色范围
                color = `hsl(${hue}, 85%, 65%)`;
                
                duration = 1200 + Math.random() * 1000;
                directionX = (Math.random() - 0.5) * (pressure / 12);
                directionY = (Math.random() - 0.5 - 0.4) * (pressure / 10);
            } else if (pressure < 500) {
                // 高压力：强烈表达
                distance = 70 + (Math.random() * pressure * 2.2);
                
                const options = [
                    'AAA!', 'あああ!!!', '啊啊啊!!!', '아아아!!!', '!!!', '?!!?!', 
                    '😱', '😫', '😖', '😵', '😨', '💥', '💫', '💢', '⚡',
                    'AHHH!', 'WOAH!', 'EEEK!', 'ARGH!', 'GYAH!'
                ];
                content = options[Math.floor(Math.random() * options.length)];
                fontSize = (20 + Math.random() * 18) * superMultiplier;
                
                const hue = Math.floor(320 + Math.random() * 40) % 360; // 洋红色-红色范围
                color = `hsl(${hue}, 90%, 60%)`;
                
                duration = 1400 + Math.random() * 1200;
                directionX = (Math.random() - 0.5) * (pressure / 8);
                directionY = (Math.random() - 0.5 - 0.5) * (pressure / 7);
            } else {
                // 极限压力：疯狂爆发
                distance = 80 + (Math.random() * pressure * 2.5);
                
                const options = [
                    'AAAAH!!!', 'あああああ!!!!', '啊啊啊啊啊!!!!', '아아아아아!!!!', 
                    '!!!!!!!', '?!!?!?!!', '😱😱😱', '😫😫', '😖😖😖', '⚡💥⚡',
                    'AHHHHH!!!', 'WOAAAH!!!', 'EEEEEK!!!', 'ARRRGH!!!'
                ];
                content = options[Math.floor(Math.random() * options.length)];
                fontSize = (24 + Math.random() * 24) * superMultiplier;
                
                // 随机亮色
                const hue = Math.floor(Math.random() * 360);
                color = `hsl(${hue}, 100%, 65%)`;
                
                duration = 1800 + Math.random() * 1500;
                directionX = (Math.random() - 0.5) * (pressure / 6) * superMultiplier;
                directionY = (Math.random() - 0.5 - 0.6) * (pressure / 5) * superMultiplier;
            }
            
            const posX = centerX + Math.cos(angle) * distance;
            const posY = centerY + Math.sin(angle) * distance;
            
            particle.style.left = posX + 'px';
            particle.style.top = posY + 'px';
            
            // 应用样式
            particle.textContent = content;
            particle.style.fontSize = fontSize + 'px';
            particle.style.color = color;
            particle.style.opacity = '0.9';
            particle.style.transform = 'rotate(' + (Math.random() * 40 - 20) + 'deg)';
            particle.style.textShadow = `0 0 5px ${color}, 0 0 10px rgba(255, 255, 255, 0.5)`;
            
            // 超级模式特效
            if (gameState.superModeActive && Math.random() > 0.7) {
                particle.style.fontWeight = 'bold';
                particle.style.border = `1px solid ${color}`;
                particle.style.padding = '2px 6px';
                particle.style.borderRadius = '8px';
                particle.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
            }
            
            // 添加到DOM
            effectsContainer.appendChild(particle);
            
            // 添加到粒子数组
            gameState.particles.push({
                element: particle,
                posX,
                posY,
                directionX,
                directionY,
                rotation: (Math.random() - 0.5) * 15 * superMultiplier,
                opacity: 0.95,
                duration,
                elapsed: 0,
                color
            });
        }
        
        function createSoundWave(pressure) {
            if (!gameState.effectsEnabled || !gameState.dynamicEffectsEnabled) return;
            
            const wave = document.createElement('div');
            wave.className = 'soundWave';
            
            const size = 80 + pressure * 1.5;
            wave.style.width = size + 'px';
            wave.style.height = size + 'px';
            
            // 居中定位
            wave.style.left = 'calc(50% - ' + (size / 2) + 'px)';
            wave.style.top = 'calc(50% - ' + (size / 2) + 'px)';
            
            // 基于压力的动画持续时间和颜色
            const duration = 1000 - (pressure * 5); // 压力越高越快
            wave.style.animationDuration = Math.max(duration, 300) + 'ms';
            
            // 高压力时颜色变化
            if (pressure > 300) {
                const hue = Math.max(0, 60 - (pressure - 300) / 10); // 从黄色到红色
                wave.style.borderColor = `hsl(${hue}, 100%, 50%)`;
                wave.style.boxShadow = `0 0 8px hsl(${hue}, 100%, 50%)`;
            }
            
            // 添加到DOM
            effectsContainer.appendChild(wave);
            
            // 添加到波数组
            gameState.soundWaves.push({
                element: wave,
                duration: Math.max(duration, 300),
                elapsed: 0
            });
        }
        
        // 创建霓虹粒子特效
        function createNeonParticle(pressure) {
            if (!gameState.effectsEnabled || !gameState.customEffectsUnlocked.includes('neon-explosion') || !gameState.dynamicEffectsEnabled) return;
            
            const particle = document.createElement('div');
            particle.className = 'neonParticle';
            
            // 随机颜色
            const hues = [0, 60, 120, 180, 240, 300]; // 红、黄、绿、青、蓝、洋红
            const hue = hues[Math.floor(Math.random() * hues.length)];
            const color = `hsl(${hue}, 100%, 70%)`;
            particle.style.backgroundColor = color;
            particle.style.color = color;
            
            // 大小基于压力
            const size = 5 + (Math.random() * pressure / 10);
            particle.style.width = size + 'px';
            particle.style.height = size + 'px';
            
            // 位置和动画
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const angle = Math.random() * Math.PI * 2;
            const distance = 10 + (Math.random() * pressure);
            
            const posX = centerX + Math.cos(angle) * distance;
            const posY = centerY + Math.sin(angle) * distance;
            
            particle.style.left = posX + 'px';
            particle.style.top = posY + 'px';
            
            // 动画参数
            const duration = 1000 + Math.random() * 2000;
            const directionX = (Math.random() - 0.5) * pressure / 10;
            const directionY = (Math.random() - 0.5) * pressure / 10;
            const gravity = 0.05 + Math.random() * 0.1;
            
            effectsContainer.appendChild(particle);
            
            gameState.neonParticles.push({
                element: particle,
                posX,
                posY,
                directionX,
                directionY,
                gravity,
                opacity: 1,
                duration,
                elapsed: 0,
                size
            });
        }
        
        // 创建文字漂浮特效
        function createTextEffect(pressure) {
            if (!gameState.effectsEnabled || !gameState.customEffectsUnlocked.includes('text-shower') || !gameState.dynamicEffectsEnabled) return;
            
            const textEffect = document.createElement('div');
            textEffect.className = 'textEffect';
            
            // 随机位置
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const posX = Math.random() * screenWidth * 0.8 + screenWidth * 0.1;
            const posY = Math.random() * screenHeight * 0.6 + screenHeight * 0.2;
            
            textEffect.style.left = posX + 'px';
            textEffect.style.top = posY + 'px';
            
            // 随机颜色和大小
            const hue = Math.floor(Math.random() * 360);
            const color = `hsl(${hue}, 100%, 60%)`;
            textEffect.style.color = color;
            
            const fontSize = 18 + Math.floor(Math.random() * 24);
            textEffect.style.fontSize = `${fontSize}px`;
            
            // 随机角度
            const rotate = Math.random() * 30 - 15;
            textEffect.style.transform = `rotate(${rotate}deg)`;
            
            // 文字内容
            const texts = [
                '释放压力!', '尖叫吧!', '感觉好些了吗?', '继续!',
                '释放!', '爆发!', '尖叫!', '呐喊!',
                '✨放松✨', '治愈中...', '压力-100', '舒适+1',
                pressure > 300 ? '太厉害了!' : '加油!',
                pressure > 500 ? '尖叫之王!' : '继续尖叫!',
                pressure > 1000 ? '压力爆表!' : '✨✨✨',
                pressure > 1500 ? '简直疯狂!' : '⚡⚡⚡',
                pressure > 2000 ? '超越极限!' : '💥💥💥'
            ];
            
            textEffect.textContent = texts[Math.floor(Math.random() * texts.length)];
            
            effectsContainer.appendChild(textEffect);
            
            // 文字效果不需要添加到数组中更新，它使用CSS动画
            setTimeout(() => {
                textEffect.remove();
            }, 1500);
        }
        
        // 创建冲击波特效
        function createShockwave(pressure) {
            if (!gameState.effectsEnabled || !gameState.customEffectsUnlocked.includes('shockwave') || !gameState.dynamicEffectsEnabled) return;
            
            const shockwave = document.createElement('div');
            shockwave.className = 'shockwave';
            
            // 中心位置
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            // 大小比例
            const maxRadius = Math.min(window.innerWidth, window.innerHeight) * 0.8;
            
            shockwave.style.left = (centerX - maxRadius / 2) + 'px';
            shockwave.style.top = (centerY - maxRadius / 2) + 'px';
            shockwave.style.width = maxRadius + 'px';
            shockwave.style.height = maxRadius + 'px';
            
            // 高压力时增加颜色效果
            if (pressure > 1000) {
                const hue = Math.floor(Math.random() * 360);
                shockwave.style.background = `radial-gradient(circle, hsla(${hue}, 100%, 70%, 0.8) 0%, rgba(255, 255, 255, 0) 70%)`;
            }
            
            effectsContainer.appendChild(shockwave);
            
            // 使用CSS动画，不需要添加到数组
            setTimeout(() => {
                shockwave.remove();
            }, 800);
        }
        
        // 创建表情符号爆炸
        function createEmojiExplosion(pressure) {
            if (!gameState.effectsEnabled || !gameState.dynamicEffectsEnabled) return;
            
            // 基于压力决定表情数量
            const count = Math.min(Math.floor(pressure / 50) + 3, 20);
            
            const emojis = [
                '😱', '😲', '😮', '😯', '😫', '😖', '😵', 
                '💥', '⚡', '💢', '💫', '✨', '💦', '🌟',
                '🔥', '⭐', '💯', '🎉', '🎊', '💨', '💣', '🌋'
            ];
            
            for (let i = 0; i < count; i++) {
                const emoji = document.createElement('div');
                emoji.className = 'emojiExplosion';
                
                // 随机表情
                emoji.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                
                // 随机位置 (从中心点发散)
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * (pressure / 5);
                
                const posX = centerX + Math.cos(angle) * distance;
                const posY = centerY + Math.sin(angle) * distance;
                
                emoji.style.left = posX + 'px';
                emoji.style.top = posY + 'px';
                
                // 随机大小（压力越大，表情可能越大）
                const size = 100 + Math.random() * (100 + pressure / 10);
                emoji.style.fontSize = `${size}%`;
                
                // 随机动画延迟
                emoji.style.animationDelay = `${Math.random() * 0.5}s`;
                
                effectsContainer.appendChild(emoji);
                
                // 清理
                setTimeout(() => {
                    emoji.remove();
                }, 3000);
            }
        }
        
        function applyScreenShake(pressure) {
            if (!gameState.effectsEnabled || pressure < 40 || !gameState.dynamicEffectsEnabled) return;
            
            const intensity = Math.min(pressure / 10, 30); // 限制最大抖动幅度
            const gameContainer = document.getElementById('gameContainer');
            
            // 清除现有的抖动
            gameContainer.style.transform = 'none';
            
            // 抖动效果的随机位置
            const shakeX = (Math.random() - 0.5) * intensity;
            const shakeY = (Math.random() - 0.5) * intensity;
            
            gameContainer.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
            
            // 短暂延迟后重置
            setTimeout(() => {
                gameContainer.style.transform = 'none';
            }, 50);
        }
        
        function updateVisualEffects(deltaTime) {
            // 更新标准粒子
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                particle.elapsed += deltaTime;
                
                if (particle.elapsed >= particle.duration) {
                    // 移除过期粒子
                    particle.element.remove();
                    gameState.particles.splice(i, 1);
                } else {
                    // 更新位置
                    particle.posX += particle.directionX * deltaTime * 0.1;
                    particle.posY += particle.directionY * deltaTime * 0.1;
                    
                    // 更新不透明度
                    const progress = particle.elapsed / particle.duration;
                    particle.opacity = 0.95 * (1 - progress);
                    
                    // 添加轻微的动态效果 - 超级模式时更强
                    const wobble = gameState.superModeActive ? 
                        Math.sin(progress * 10) * 3 : 
                        Math.sin(progress * 6) * 1.5;
                    
                    // 应用更新
                    particle.element.style.left = particle.posX + 'px';
                    particle.element.style.top = particle.posY + 'px';
                    particle.element.style.opacity = particle.opacity;
                    
                    // 随时间变换
                    const rotationAmount = particle.rotation * progress * 10;
                    const scaleEffect = 1 - progress * 0.3; // 随时间轻微缩小
                    
                    particle.element.style.transform = `
                        rotate(${rotationAmount + wobble}deg) 
                        scale(${scaleEffect})
                    `;
                    
                    // 颜色变换特效
                    if (gameState.customEffectsUnlocked.includes('color-shift') && Math.random() < 0.1) {
                        const hue = (parseFloat(particle.color.match(/hsl\((\d+)/)[1]) + 10) % 360;
                        const newColor = `hsl(${hue}, 85%, 60%)`;
                        particle.element.style.color = newColor;
                        particle.element.style.textShadow = `0 0 5px ${newColor}`;
                        particle.color = newColor;
                    }
                }
            }
            
            // 更新声波
            for (let i = gameState.soundWaves.length - 1; i >= 0; i--) {
                const wave = gameState.soundWaves[i];
                wave.elapsed += deltaTime;
                
                if (wave.elapsed >= wave.duration) {
                    // 移除过期波
                    wave.element.remove();
                    gameState.soundWaves.splice(i, 1);
                }
            }
            
            // 更新霓虹粒子
            for (let i = gameState.neonParticles.length - 1; i >= 0; i--) {
                const particle = gameState.neonParticles[i];
                particle.elapsed += deltaTime;
                
                if (particle.elapsed >= particle.duration) {
                    particle.element.remove();
                    gameState.neonParticles.splice(i, 1);
                } else {
                    // 更新位置，加入重力和阻尼效果
                    particle.directionY += particle.gravity * (deltaTime / 16); // 重力
                    
                    particle.posX += particle.directionX * (deltaTime / 16) * 3;
                    particle.posY += particle.directionY * (deltaTime / 16) * 3;
                    
                    // 随时间变化大小和不透明度
                    const progress = particle.elapsed / particle.duration;
                    particle.opacity = 1 - progress;
                    
                    const currentSize = particle.size * (1 - progress * 0.7);
                    
                    // 应用更新
                    particle.element.style.left = particle.posX + 'px';
                    particle.element.style.top = particle.posY + 'px';
                    particle.element.style.opacity = particle.opacity;
                    particle.element.style.width = currentSize + 'px';
                    particle.element.style.height = currentSize + 'px';
                }
            }
            
            // 更新星星
            for (let i = gameState.stars.length - 1; i >= 0; i--) {
                const star = gameState.stars[i];
                star.elapsed += deltaTime;
                
                if (star.elapsed >= star.duration) {
                    star.element.remove();
                    gameState.stars.splice(i, 1);
                }
            }
            
            // 更新闪电
            for (let i = gameState.lightnings.length - 1; i >= 0; i--) {
                const lightning = gameState.lightnings[i];
                lightning.elapsed += deltaTime;
                
                if (lightning.elapsed >= lightning.duration) {
                    lightning.element.remove();
                    gameState.lightnings.splice(i, 1);
                }
            }
        }
        
        // 触摸事件处理程序
        function handleTouchStart(e) {
            e.preventDefault();
            if (gameState.isPressed) return;
            
            gameState.isPressed = true;
            gameState.pressStartTime = Date.now();
            gameState.currentPressure = 0;
            gameState.lastPressureUpdate = Date.now();
            
            // 触发按钮波纹效果
            triggerButtonRipple();
            
            // 处理快速按压检测
            if (gameState.rapidPressTimeout) {
                clearTimeout(gameState.rapidPressTimeout);
                gameState.rapidPressCount++;
                
                if (gameState.rapidPressCount >= 3) {
                    gameState.touchType = 'rapid';
                    // 改变嘴巴到快速模式
                    mouthButton.textContent = '😬';
                }
            } else {
                gameState.rapidPressCount = 1;
            }
            
            gameState.rapidPressTimeout = setTimeout(() => {
                gameState.rapidPressCount = 0;
                gameState.rapidPressTimeout = null;
            }, 500);
            
            // 以正常表情开始
            if (gameState.touchType !== 'rapid') {
                mouthButton.textContent = '😮';
            }
            
            // 如果尚未运行，则启动动画循环
            if (!gameState.animationFrameId) {
                gameState.lastFrame = Date.now();
                gameState.animationFrameId = requestAnimationFrame(gameLoop);
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            if (!gameState.isPressed) return;
            
            gameState.isPressed = false;
            const pressDuration = Date.now() - gameState.pressStartTime;
            
            // 如果尚未确定为快速按压，则确定按压类型
            if (gameState.touchType !== 'rapid') {
                if (pressDuration < 300) {
                    gameState.touchType = 'short';
                    mouthButton.textContent = '😯';
                } else {
                    gameState.touchType = 'long';
                    
                    // 根据最终压力重置嘴巴
                    if (gameState.currentPressure > 2000) {
                        mouthButton.textContent = '🤯';
                    } else if (gameState.currentPressure > 1000) {
                        mouthButton.textContent = '😵';
                    } else if (gameState.currentPressure > 500) {
                        mouthButton.textContent = '😱';
                    } else if (gameState.currentPressure > 200) {
                        mouthButton.textContent = '😫';
                    } else if (gameState.currentPressure > 80) {
                        mouthButton.textContent = '😲';
                    } else {
                        mouthButton.textContent = '😮';
                    }
                }
            }
            
            // 处理释放效果
            handlePressureRelease();
            
            // 延迟后重置
            setTimeout(() => {
                mouthButton.textContent = '😮';
                gameState.touchType = '';
                gameState.currentPressure = 0;
                updatePressureDisplay();
                
                // 重置按钮形状
                if (gameState.customEffectsUnlocked.includes('button-morph')) {
                    mouthButton.style.borderRadius = '50%';
                    mouthButton.style.clipPath = 'none';
                }
                
                // 重置背景
                if (gameState.backgroundAnimationActive) {
                    document.body.style.background = 'linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%)';
                    dynamicBackground.style.opacity = '0';
                    dynamicBackground.style.animation = 'none';
                }
                
                // 重置波浪动画
                if (gameState.waveAnimationActive) {
                    waveContainer.style.opacity = '0';
                    gameState.waveAnimationActive = false;
                }
                
                // 停止星星生成
                if (gameState.starCreationInterval) {
                    clearInterval(gameState.starCreationInterval);
                    gameState.starCreationInterval = null;
                }
                
                // 清除标题颜色
                gameHeader.style.color = '#333';
                gameHeader.style.textShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
            }, 1000);
        }
        
        function handlePressureRelease() {
            // 保存达到的最大压力
            const finalPressure = gameState.currentPressure;
            gameState.maxPressure = Math.max(gameState.maxPressure, finalPressure);
            
            // 更新统计数据
            gameState.totalPressureReleased += finalPressure;
            
            // 检查成就解锁
            checkAchievements(finalPressure);
            
            // 检查自定义效果解锁
            checkCustomEffectsUnlock(finalPressure);
            
            // 保存打卡
            saveCheckin(finalPressure);
            
            // 显示完成消息
            const messages = [
                '今日打卡完成！',
                `释放压力值: ${Math.floor(finalPressure)}`,
                '感觉好些了吗？',
                '压力已释放！',
                '尖叫真痛快！',
                '很好的释放！',
                finalPressure > 1000 ? '太厉害了！压力爆表！' : '尖叫技巧不错！',
                finalPressure > 2000 ? '简直不可思议！超越极限！' : '释放得很彻底！'
            ];
            
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            showPopupMessage(randomMessage, 2000);
            
            // 根据压力和触摸类型创建爆发效果
            if (gameState.effectsEnabled) {
                // 基础效果
                const isSuper = gameState.superModeActive;
                
                if (gameState.touchType === 'rapid') {
                    // 快速按压效果：大量小粒子
                    const count = isSuper ? 50 : 30;
                    for (let i = 0; i < count; i++) {
                        createParticle(finalPressure);
                    }
                    
                    if (finalPressure > 200) {
                        createEmojiExplosion(finalPressure);
                    }
                } else if (gameState.touchType === 'short') {
                    // 短按效果：少量中等粒子
                    const count = isSuper ? 20 : 10;
                    for (let i = 0; i < count; i++) {
                        createParticle(finalPressure);
                    }
                } else {
// 长按效果：基于压力
                    const scaleFactor = isSuper ? 1.5 : 1;
                    const baseCount = Math.floor((finalPressure / (isSuper ? 15 : 20)) + 5);
                    const particleCount = Math.min(baseCount, 150); // 限制最大数量避免性能问题
                    
                    // 主爆发效果
                    for (let i = 0; i < particleCount; i++) {
                        createParticle(finalPressure);
                    }
                    
                    // 高压力的额外效果
                    if (finalPressure > 70) {
                        // 创建表情爆发
                        createEmojiExplosion(finalPressure);
                        
                        // 创建持续爆发的效果
                        const burstCount = Math.min(Math.floor(finalPressure / 25), 30);
                        for (let i = 0; i < burstCount; i++) {
                            setTimeout(() => {
                                createParticle(finalPressure);
                                applyScreenShake(finalPressure);
                                
                                // 特殊解锁的效果
                                if (i % 3 === 0 && gameState.customEffectsUnlocked.includes('neon-explosion')) {
                                    for (let j = 0; j < 5; j++) {
                                        createNeonParticle(finalPressure);
                                    }
                                }
                                
                                if (i % 4 === 0 && gameState.customEffectsUnlocked.includes('text-shower')) {
                                    createTextEffect(finalPressure);
                                }
                                
                                if (i === 0 && gameState.customEffectsUnlocked.includes('shockwave')) {
                                    createShockwave(finalPressure);
                                }
                                
                            }, i * 50 * (isSuper ? 0.7 : 1));
                        }
                    }
                    
                    // 超高压力特效 (500+)
                    if (finalPressure > 500) {
                        // 创建大型冲击波效果
                        if (gameState.customEffectsUnlocked.includes('shockwave')) {
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => {
                                    createShockwave(finalPressure);
                                }, i * 300);
                            }
                        }
                        
                        // 创建更多文字效果
                        if (gameState.customEffectsUnlocked.includes('text-shower')) {
                            for (let i = 0; i < 5; i++) {
                                setTimeout(() => {
                                    createTextEffect(finalPressure);
                                }, i * 200);
                            }
                        }
                        
                        // 临时激活按钮形变动画
                        if (gameState.customEffectsUnlocked.includes('button-morph')) {
                            triggerButtonMorphAnimation();
                        }
                    }
                    
                    // 极限压力特效 (1000+)
                    if (finalPressure > 1000) {
                        // 创建闪电效果
                        if (gameState.customEffectsUnlocked.includes('lightning')) {
                            for (let i = 0; i < 5; i++) {
                                setTimeout(() => {
                                    createLightning(finalPressure);
                                }, i * 200);
                            }
                        }
                        
                        // 超大规模粒子爆发
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                const burstSize = Math.min(Math.floor(finalPressure / 50), 50);
                                for (let j = 0; j < burstSize; j++) {
                                    createParticle(finalPressure * 0.8);
                                }
                                createEmojiExplosion(finalPressure);
                                applyScreenShake(finalPressure * 0.7);
                            }, i * 500);
                        }
                    }
                    
                    // 超级极限压力特效 (2000+)
                    if (finalPressure > 2000) {
                        // 疯狂多重爆发
                        for (let i = 0; i < 8; i++) {
                            setTimeout(() => {
                                // 全屏闪烁效果
                                document.body.style.backgroundColor = `rgba(255, ${Math.random() * 255}, ${Math.random() * 255}, 0.1)`;
                                setTimeout(() => {
                                    document.body.style.backgroundColor = '';
                                }, 100);
                                
                                // 多重冲击波
                                if (gameState.customEffectsUnlocked.includes('shockwave')) {
                                    createShockwave(finalPressure);
                                }
                                
                                // 爆炸效果
                                createEmojiExplosion(finalPressure);
                                
                                // 重型屏幕震动
                                applyScreenShake(finalPressure * 0.3);
                                
                                // 闪电风暴
                                if (gameState.customEffectsUnlocked.includes('lightning')) {
                                    for (let j = 0; j < 3; j++) {
                                        setTimeout(() => {
                                            createLightning(finalPressure);
                                        }, j * 100);
                                    }
                                }
                            }, i * 300);
                        }
                    }
                }
            }
        }
        
        // 检查成就解锁
        function checkAchievements(pressure) {
            // 检查压力值成就
            for (let achievement of achievements) {
                if (achievement.unlocked) continue;
                
                let shouldUnlock = false;
                
                if (achievement.type === 'pressure' && pressure >= achievement.unlockAt) {
                    shouldUnlock = true;
                } else if (achievement.type === 'totalPressure' && gameState.totalPressureReleased >= achievement.unlockAt) {
                    shouldUnlock = true;
                } else if (achievement.type === 'rapidPress' && gameState.touchType === 'rapid' && gameState.rapidPressCount >= achievement.unlockAt) {
                    shouldUnlock = true;
                }
                
                if (shouldUnlock) {
                    // 标记为已解锁
                    achievement.unlocked = true;
                    
                    // 如果是超级模式成就，激活超级模式
                    if (achievement.id === 'super-mode') {
                        toggleSuperMode(true);
                    }
                    
                    // 如果是形变大师成就，激活形变效果
                    if (achievement.id === 'morph-master' && !gameState.customEffectsUnlocked.includes('button-morph')) {
                        gameState.customEffectsUnlocked.push('button-morph');
                        saveCustomEffects();
                    }
                    
                    // 显示成就通知
                    showAchievement(achievement.title, achievement.description);
                    
                    // 保存成就状态
                    saveAchievements();
                }
            }
        }
        
        // 检查自定义效果解锁
        function checkCustomEffectsUnlock(pressure) {
            for (let effect of customEffects) {
                if (gameState.customEffectsUnlocked.includes(effect.id)) continue;
                
                if (effect.type === 'pressure' && pressure >= effect.unlockAt) {
                    // 解锁新效果
                    gameState.customEffectsUnlocked.push(effect.id);
                    effect.enabled = true;
                    
                    // 显示解锁通知
                    showPopupMessage(`新特效解锁: ${effect.name}！`, 2000);
                    
                    // 保存效果状态
                    saveCustomEffects();
                    
                    // 如果解锁了背景波浪，立即激活一次
                    if (effect.id === 'wave-background') {
                        waveContainer.style.opacity = '1';
                        gameState.waveAnimationActive = true;
                        setTimeout(() => {
                            waveContainer.style.opacity = '0';
                            gameState.waveAnimationActive = false;
                        }, 3000);
                    }
                    
                    // 如果解锁了按钮形变，立即展示一次
                    if (effect.id === 'button-morph') {
                        setTimeout(() => {
                            triggerButtonMorphAnimation();
                        }, 500);
                    }
                }
            }
        }
        
        // 显示成就通知
        function showAchievement(title, description) {
            const achievementPopup = document.getElementById('achievementPopup');
            const titleElement = achievementPopup.querySelector('.achievementTitle');
            const descElement = achievementPopup.querySelector('.achievementDesc');
            
            titleElement.textContent = '🏆 ' + title;
            descElement.textContent = description;
            
            achievementPopup.style.display = 'block';
            
            setTimeout(() => {
                achievementPopup.style.display = 'none';
            }, 3000);
        }
        
        // 保存成就和自定义效果状态
        function saveAchievements() {
            if (!storageAvailable('localStorage')) return;
            
            localStorage.setItem('screamAchievements', JSON.stringify(
                achievements.map(a => ({ id: a.id, unlocked: a.unlocked }))
            ));
        }
        
        function saveCustomEffects() {
            if (!storageAvailable('localStorage')) return;
            
            localStorage.setItem('screamCustomEffects', JSON.stringify(
                gameState.customEffectsUnlocked
            ));
        }
        
        // 加载成就和自定义效果状态
        function loadAchievements() {
            if (!storageAvailable('localStorage')) return;
            
            const savedAchievements = JSON.parse(localStorage.getItem('screamAchievements') || '[]');
            
            for (let saved of savedAchievements) {
                const achievement = achievements.find(a => a.id === saved.id);
                if (achievement) {
                    achievement.unlocked = saved.unlocked;
                }
            }
        }
        
        function loadCustomEffects() {
            if (!storageAvailable('localStorage')) return;
            
            const savedEffects = JSON.parse(localStorage.getItem('screamCustomEffects') || '[]');
            gameState.customEffectsUnlocked = savedEffects;
            
            for (let effectId of savedEffects) {
                const effect = customEffects.find(e => e.id === effectId);
                if (effect) {
                    effect.enabled = true;
                }
            }
        }
        
        // 超级模式开关
        function toggleSuperMode(forceState = null) {
            // 检查是否已解锁超级模式
            const superModeAchievement = achievements.find(a => a.id === 'super-mode');
            if (!superModeAchievement.unlocked) {
                showPopupMessage('需要达到300点压力值解锁超级模式', 2000);
                return;
            }
            
            // 设置状态
            if (forceState !== null) {
                gameState.superModeActive = forceState;
            } else {
                gameState.superModeActive = !gameState.superModeActive;
            }
            
            // 更新UI
            const toggleButton = document.getElementById('toggleSuper');
            toggleButton.textContent = gameState.superModeActive ? '🔥' : '💤';
            
            // 超级模式指示器
            let indicator = document.querySelector('.superModeIndicator');
            
            if (gameState.superModeActive) {
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.className = 'superModeIndicator';
                    indicator.textContent = '🔥 超级模式 🔥';
                    document.getElementById('gameContainer').appendChild(indicator);
                }
                
                // 超级模式自动关闭定时器
                if (gameState.superModeTimer) {
                    clearTimeout(gameState.superModeTimer);
                }
                
                gameState.superModeTimer = setTimeout(() => {
                    toggleSuperMode(false);
                }, 60000); // 60秒后自动关闭
                
                // 显示提示
                showPopupMessage('超级模式已激活！释放压力效果增强！', 2000);
                
                // 特效展示
                setTimeout(() => {
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            createParticle(300);
                        }, i * 100);
                    }
                    
                    if (gameState.customEffectsUnlocked.includes('neon-explosion')) {
                        for (let i = 0; i < 15; i++) {
                            setTimeout(() => {
                                createNeonParticle(300);
                            }, i * 80);
                        }
                    }
                }, 500);
            } else {
                if (indicator) {
                    indicator.remove();
                }
                
                if (gameState.superModeTimer) {
                    clearTimeout(gameState.superModeTimer);
                    gameState.superModeTimer = null;
                }
            }
        }
        
        // UI更新功能
        function updatePressureDisplay() {
            // 计算压力条宽度，最大100%
            const barWidth = Math.min(gameState.currentPressure, 100);
            pressureBar.style.width = barWidth + '%';
            
            // 更新压力值显示
            pressureValue.textContent = Math.floor(gameState.currentPressure);
            
            // 调整压力条的渐变位置，以在高压力下显示红色区域
            if (gameState.currentPressure > 100) {
                const gradientPos = Math.min((gameState.currentPressure - 100) / 5, 100);
                pressureBar.style.backgroundPosition = `${gradientPos}% 0`;
            } else {
                pressureBar.style.backgroundPosition = '0% 0';
            }
            
            // 根据压力更新按钮外观
            if (gameState.isPressed) {
                if (gameState.touchType !== 'rapid') {
                    if (gameState.currentPressure > 2000) {
                        mouthButton.textContent = '🤯';
                    } else if (gameState.currentPressure > 1000) {
                        mouthButton.textContent = '😵';
                    } else if (gameState.currentPressure > 500) {
                        mouthButton.textContent = '😱';
                    } else if (gameState.currentPressure > 200) {
                        mouthButton.textContent = '😫';
                    } else if (gameState.currentPressure > 80) {
                        mouthButton.textContent = '😲';
                    } else if (gameState.currentPressure > 20) {
                        mouthButton.textContent = '😯';
                    }
                }
                
                // 随压力稍微缩放按钮
                let scale = 1;
                
                if (gameState.currentPressure <= 100) {
                    scale = 1 + (gameState.currentPressure / 500);
                } else if (gameState.currentPressure <= 500) {
                    scale = 1.2 + ((gameState.currentPressure - 100) / 1000);
                } else {
                    scale = 1.6 + ((gameState.currentPressure - 500) / 5000);
                }
                
                mouthButton.style.transform = `scale(${scale})`;
                
                // 超高压力时添加发光效果
                if (gameState.currentPressure > 300) {
                    const intensity = Math.min((gameState.currentPressure - 300) / 10, 30);
                    mouthButton.style.boxShadow = `0 8px 20px rgba(255, 107, 107, 0.4), 
                                                   0 2px 8px rgba(0, 0, 0, 0.2),
                                                   inset 0 -2px 5px rgba(0, 0, 0, 0.1),
                                                   inset 0 2px 5px rgba(255, 255, 255, 0.5),
                                                   0 0 ${intensity}px ${intensity/2}px rgba(255, 50, 50, 0.8)`;
                }
                
                // 按钮形变
                if (gameState.currentPressure > 50 && gameState.customEffectsUnlocked.includes('button-morph')) {
                    updateButtonShape(gameState.currentPressure);
                }
                
                // 背景颜色更新
                updateBackgroundColor(gameState.currentPressure);
                
                // 星星背景
                createStarField();
                
                // 高压随机闪电
                if (gameState.currentPressure > 900 && gameState.customEffectsUnlocked.includes('lightning')) {
                    if (Math.random() < 0.01) {
                        createLightning(gameState.currentPressure);
                    }
                }
            } else {
                mouthButton.style.transform = 'scale(1)';
                mouthButton.style.boxShadow = `0 8px 20px rgba(255, 107, 107, 0.4), 
                                              0 2px 8px rgba(0, 0, 0, 0.2),
                                              inset 0 -2px 5px rgba(0, 0, 0, 0.1),
                                              inset 0 2px 5px rgba(255, 255, 255, 0.5)`;
            }
        }
        
        function showPopupMessage(message, duration) {
            popupMessage.textContent = message;
            popupMessage.style.display = 'block';
            
            setTimeout(() => {
                popupMessage.style.display = 'none';
            }, duration);
        }
        
        // 主游戏循环
        function gameLoop() {
            const now = Date.now();
            const deltaTime = now - gameState.lastFrame;
            gameState.lastFrame = now;
            
            // 如果按钮被按下，则更新压力
            if (gameState.isPressed) {
                const elapsedSinceUpdate = now - gameState.lastPressureUpdate;
                
                if (elapsedSinceUpdate >= 100) { // 每100ms更新一次
                    // 基于触摸类型的不同压力增长率
                    let increaseAmount;
                    
                    if (gameState.touchType === 'rapid') {
                        increaseAmount = gameState.pressureIncreaseRate * 2.5;
                    } else {
                        increaseAmount = gameState.pressureIncreaseRate;
                    }
                    
                    // 长按时间越长，增长率越大
                    const pressTime = now - gameState.pressStartTime;
                    const timeBonus = (pressTime > 3000) ? (pressTime - 3000) / 10000 : 0;
                    increaseAmount += timeBonus;
                    
                    // 超级模式增加增长率
                    if (gameState.superModeActive) {
                        increaseAmount *= 1.5;
                    }
                    
                    // 不再设置上限值
                    gameState.currentPressure += increaseAmount;
                    gameState.lastPressureUpdate = now;
                    
                    // 基于压力创建视觉效果
                    if (gameState.currentPressure > 20) {
                        createSoundWave(Math.min(gameState.currentPressure, 300)); // 限制声波大小
                        
                        if (Math.random() < gameState.currentPressure / 500) {
                            createParticle(gameState.currentPressure);
                        }
                        
                        if (gameState.currentPressure > 40 && Math.random() < 0.3) {
                            applyScreenShake(Math.min(gameState.currentPressure, 200)); // 限制抖动幅度
                        }
                        
                        // 高压力特殊效果
                        if (gameState.currentPressure > 300 && gameState.customEffectsUnlocked.includes('neon-explosion') && Math.random() < 0.05) {
                            createNeonParticle(gameState.currentPressure);
                        }
                        
                        if (gameState.currentPressure > 400 && gameState.customEffectsUnlocked.includes('text-shower') && Math.random() < 0.02) {
                            createTextEffect(gameState.currentPressure);
                        }
                    }
                }
                
                updatePressureDisplay();
            }
            
            // 更新所有视觉效果
            updateVisualEffects(deltaTime);
            
            // 继续循环
            gameState.animationFrameId = requestAnimationFrame(gameLoop);
            
            // 如果没有活动且没有动画特效，停止循环
            if (!gameState.isPressed && 
                gameState.particles.length === 0 && 
                gameState.soundWaves.length === 0 && 
                gameState.neonParticles.length === 0 && 
                gameState.stars.length === 0 && 
                gameState.lightnings.length === 0) {
                cancelAnimationFrame(gameState.animationFrameId);
                gameState.animationFrameId = null;
            }
        }
        
        // 控制功能
        function toggleCheckinPanel() {
            gameState.checkinVisible = !gameState.checkinVisible;
            checkinPanel.style.display = gameState.checkinVisible ? 'block' : 'none';
            
            if (gameState.checkinVisible) {
                updateCheckinDisplay();
            }
        }
        
        function toggleEffectsEnabled() {
            gameState.effectsEnabled = !gameState.effectsEnabled;
            toggleEffects.textContent = gameState.effectsEnabled ? '✨' : '🚫';
            
            if (!gameState.effectsEnabled) {
                // 清除所有现有效果
                effectsContainer.innerHTML = '';
                gameState.particles = [];
                gameState.soundWaves = [];
                gameState.neonParticles = [];
                gameState.textEffects = [];
                gameState.shockwaves = [];
                gameState.stars = [];
                gameState.lightnings = [];
                
                // 关闭背景动画
                if (gameState.backgroundAnimationActive) {
                    document.body.style.background = 'linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%)';
                    dynamicBackground.style.opacity = '0';
                    dynamicBackground.style.animation = 'none';
                    gameState.backgroundAnimationActive = false;
                }
                
                // 关闭动态效果
                gameState.dynamicEffectsEnabled = false;
                
                // 重置波浪
                waveContainer.style.opacity = '0';
                gameState.waveAnimationActive = false;
                
                // 重置按钮形状
                mouthButton.style.borderRadius = '50%';
                mouthButton.style.clipPath = 'none';
                
                // 停止星星生成
                if (gameState.starCreationInterval) {
                    clearInterval(gameState.starCreationInterval);
                    gameState.starCreationInterval = null;
                }
            } else {
                // 重新启用动态效果
                gameState.dynamicEffectsEnabled = true;
            }
        }
        
        function toggleSoundEnabled() {
            gameState.soundEnabled = !gameState.soundEnabled;
            toggleSound.textContent = gameState.soundEnabled ? '🔊' : '🔇';
            
            // 将来可以实现实际的声音效果
        }
        
        // 初始化功能
        function init() {
            // 加载成就和自定义效果
            loadAchievements();
            loadCustomEffects();
            
            // 加载累计释放值
            const statsData = loadStatsData();
            gameState.totalPressureReleased = statsData.totalReleased || 0;
            
            // 更新超级模式按钮
            const superModeAchievement = achievements.find(a => a.id === 'super-mode');
            if (superModeAchievement && superModeAchievement.unlocked) {
                toggleSuper.textContent = '💤'; // 解锁但未激活
            } else {
                toggleSuper.textContent = '🔒'; // 未解锁
            }
            
            // 初始化打卡面板
            updateCheckinDisplay();
            
            // 显示欢迎消息
            setTimeout(() => {
                showPopupMessage('欢迎使用尖叫爆发器Plus版！', 2000);
                
                // 初始特效展示
                setTimeout(() => {
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            createParticle(50);
                        }, i * 100);
                    }
                    
                    // 按钮波纹效果
                    triggerButtonRipple();
                    
                }, 500);
            }, 500);
        }
        
        // 事件监听器
        mouthButton.addEventListener('touchstart', handleTouchStart);
        mouthButton.addEventListener('touchmove', handleTouchMove);
        mouthButton.addEventListener('touchend', handleTouchEnd);
        
        // 鼠标回退，用于在桌面上测试
        mouthButton.addEventListener('mousedown', handleTouchStart);
        mouthButton.addEventListener('mousemove', handleTouchMove);
        mouthButton.addEventListener('mouseup', handleTouchEnd);
        
        // 控制按钮
        toggleCheckin.addEventListener('click', toggleCheckinPanel);
        toggleEffects.addEventListener('click', toggleEffectsEnabled);
        toggleSuper.addEventListener('click', () => toggleSuperMode());
        toggleSound.addEventListener('click', toggleSoundEnabled);
        
        // 防止默认触摸行为以避免滚动
        document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        
        // 初始化
        init();
    </script>
</body>
</html>
